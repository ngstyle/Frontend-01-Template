# 看JS中的Number类型, Why 0.1+0.2 != 0.3

###	简单的结论

计算机中所有的数据都是以`二进制`存储的，所以在计算时计算机要把数据先转换成`二进制`进行计算，然后在把计算结果转换成`十进制`。

在计算`0.1+0.2`时，`二进制`计算发生了精度丢失，导致再转换成`十进制`后和预计的结果不符。



### 浮点数的存储

首先要搞清楚 JavaScript 如何存储小数。和其它语言如 Java 和 Python 不同，JavaScript 中所有数字包括整数和小数都只有一种类型 — `Number`。它的实现遵循 [IEEE 754](http://grouper.ieee.org/groups/754/) 标准，使用 64 位固定长度来表示，也就是标准的 double 双精度浮点数（相关的还有float 32位单精度）。

这样的存储结构优点是可以归一化处理整数和小数，节省存储空间。

64位比特又可分为三个部分：

- 符号位S：第 1 位是正负数符号位（sign），0代表正数，1代表负数
- 指数位E：中间的 11 位存储指数（exponent），用来表示次方数
- 尾数位M：最后的 52 位是尾数（mantissa），超出的部分自动进一舍零

![](https://camo.githubusercontent.com/af8c1cdd9aedced18be47e40d27208b671b4a18d/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f37323637613538623239383932633362373233653364366333663733393035612e706e67)

实际数字就可以用以下公式来计算：

$$
V = (-1)^{S}*2^{E}*M
$$

注意以上的公式遵循科学计数法的规范，在十进制是为0<M<10，到二进行就是0<M<2。也就是说整数部分只能是1，所以可以被舍去，只保留后面的小数部分。如 4.5 转换成二进制就是 100.1，科学计数法表示是 1.001*2^2，舍去1后 `M = 001`。E是一个无符号整数，因为长度是11位，取值范围是 0~2047。但是科学计数法中的指数是可以为负数的，所以再减去一个中间数 1023，[0,1022]表示为负，[1024,2047] 表示为正。如4.5 的指数`E = 1025`，尾数M为 001。

最终的公式变成：

$$
V = (-1)^{S}*2^{E-1023}*(M+1)
$$
所以 `4.5` 最终表示为（M=001、E=1025）：

![4.5 allocation map](https://camo.githubusercontent.com/33b3006b6e3b7a15b9bda858ac01a372981ff248/687474703a2f2f617461322d696d672e636e2d68616e677a686f752e696d672d7075622e616c6979756e2d696e632e636f6d2f33353661306164643137356263663436393664353731613862656232303633642e706e67)



### 为什么 `0.1+0.2=0.30000000000000004`？

**0.1的二进制**：

```
0.2.toString(2)
0.0001100110011001100110011001100110011001100110011001101
```

**0.2的二进制**：

```
0.2.toString(2)
0.001100110011001100110011001100110011001100110011001101
```

**理论上讲，由上面的结果相加应该：**：

```
0.0100110011001100110011001100110011001100110011001100111
```

**实际JS计算得到的0.1+0.2的二进制**

```
(0.1+0.2).toString(2)
0.0100110011001100110011001100110011001100110011001101
```

```
    // 小数2进制转10进制：
    function to10(n) {
      const pre = (n.split('.')[0] - 0).toString(2);
      const arr = n.split('.')[1].split('');
      let i = 0;
      let result = 0;
      while (i < arr.length) {
        result += arr[i] * Math.pow(2, -(i + 1));
        i++;
      }
      return result;
    }
```

在计算`0.1+0.2`时，`二进制`计算发生了精度丢失，导致再转换成`十进制`后和预计的结果不符。



### 最大安全数字

JavaScript中`Number.MAX_SAFE_INTEGER`表示最大安全数字,计算结果是`9007199254740991`，即在这个数范围内不会出现精度丢失（小数除外）,这个数实际上是(二进制):
$$
1.111...* 2^{52}
$$
也就是十进制的:

$$
2^{53}
$$

我们同样可以用一些开源库来处理大整数：

- [node-bignum](https://github.com/justmoon/node-bignum)
- [node-bigint](https://github.com/substack/node-bigint)

其实官方也考虑到了这个问题，`bigInt`类型在`es10`中被提出，现在`Chrome`中已经可以使用。




> [JavaScript 浮点数陷阱及解法](https://github.com/camsong/blog/issues/9)
>
> [一个函数让你看懂 'Why 0.1+0.2!=0.3'](https://juejin.im/post/5c7be6c56fb9a049ff4ed96e#heading-9)
>
> [从0.1+0.2=0.30000000000000004再看JS中的Number类型](https://juejin.im/post/5a6fce10f265da3e261c3c71)
>
> [揭秘 0.1 + 0.2 != 0.3](https://www.barretlee.com/blog/2016/09/28/ieee754-operation-in-js/)

